{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scaffold","text":"<p>Scaffold is a project generation tool similar to cookiecutter written in Go that leverages the Go template engine to generate projects from a template. It is designed to be used with git or the local file system with a built in \"scaffold\" management system for versions and templates.</p> <p>What set's Scaffold apart from projects like cookiecutter is the ability to define reusable scaffolds called <code>template scaffolds</code> within a project to help bootstrap code changes in existing projects.</p> <p>You're able to use a <code>.scaffolds</code> directory within a project to define a scaffold that can generate files in multiple locations around your project and even inject code into existing files. This is useful for generating boilerplate starter code for:</p> <ul> <li>React/Vue/Angular/... components</li> <li>Ansible Roles</li> <li>CRUD API endpoint stubs</li> <li>Other commonly structured code folders</li> </ul> <p>See the examples folder for some examples of how to use Scaffold.</p>"},{"location":"#core-features","title":"Core Features","text":"<ul> <li> Generate projects from a template</li> <li> Git based scaffolds<ul> <li> Update scaffolds with <code>scaffold update</code></li> <li> List scaffolds with <code>scaffold list</code></li> <li> Pull specific tag or branch</li> </ul> </li> <li> Generate files in multiple locations within an existing project</li> <li> Pre/Post Messages defined in the scaffold (supports markdown)</li> <li> Alias support for shortening common commands</li> <li> Shortcuts for common prefixes (e.g <code>gh:</code> for github.com)</li> <li> Conditional Prompting based on user input</li> <li> Inject snippets into existing files with Scaffold Templates</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#homebrew","title":"Homebrew","text":"<pre><code>brew tap hay-kot/scaffold-tap\n\nbrew install scaffold\n</code></pre>"},{"location":"#go","title":"Go","text":"<pre><code>go install github.com/hay-kot/scaffold@latest\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>scaffold new &lt;scaffold&gt; [flags]\n</code></pre> <p>See scaffold --help for all available commands and flags</p>"},{"location":"#terminology","title":"Terminology","text":"<p>Some of the terms used in the documentation and project can be somewhat general, these definitions help clarify the meaning of the terms used.</p> <code>scaffold</code> <p>a generic term for a repository or directory that has a <code>scaffold.{yml,yaml}</code> file in it.</p> <code>project</code> <p>a <code>scaffold</code> type that is used to generate a new project, it contains one of the special scaffold project directories</p> <code>template</code> <p>a <code>scaffold</code> type that uses the rewrite feature to generate files into multiple places. This is used in an existing directory to add new files. You would use a <code>template scaffold</code> to generate the boilerplate files for a new Vue component or Ansible role.</p>"},{"location":"#featured-scaffolds","title":"Featured Scaffolds","text":""},{"location":"#go-cli","title":"Go CLI","text":"<p>github.com/hay-kot/scaffold-go-cli</p> <ul> <li>CI/CD with Github Actions or Drone.io<ul> <li>PR/Commit/Release workflows</li> </ul> </li> <li>GoReleaser for releases</li> <li>GolangCI-Lint for linting</li> <li>Build/Version/Commit injection on build</li> </ul>"},{"location":"scaffold-file/","title":"Scaffold File","text":""},{"location":"scaffold-file/#overview","title":"Overview","text":"<p>There are two types of scaffolds you can define</p>"},{"location":"scaffold-file/#project-scaffolds","title":"Project Scaffolds","text":"<p>The Project generation scaffolds are used to generate a new project from a template directory. The file structure requires a root directory with one of the following names. All files within that directory will be copied to the destination directory and rendered as a template with the template engine.</p> <ul> <li>{{ .Project }}</li> <li>{{ .ProjectSlug }}</li> <li>{{ .ProjectSnake }}</li> <li>{{ .ProjectKebab }}</li> <li>{{ .ProjectCamel }}</li> </ul> <pre><code>\u251c\u2500\u2500 scaffold # can be any name\n \u00a0\u00a0 \u251c\u2500\u2500 scaffold.yaml\n\u00a0 \u00a0 \u2514\u2500\u2500 {{ .Project }} # can be any of the project name formats\n\u00a0 \u00a0     \u2514\u2500\u2500 any nested amount of files...\n</code></pre>"},{"location":"scaffold-file/#template-scaffolds","title":"Template Scaffolds","text":"<p>The template scaffolds are used to generate files within an existing project. The file structure requires a <code>templates</code> file in the root directory. The <code>templates</code> directory is used to store files that should be rewritten using the Rewrites configuration in the <code>scaffold.yaml</code> file.</p> <pre><code>\u251c\u2500\u2500 .scaffolds # in your project directory\n \u00a0\u00a0 \u2514\u2500\u2500 my-scaffold # can be any name\n \u00a0\u00a0     \u251c\u2500\u2500 scaffold.yaml\n \u00a0 \u00a0    \u2514\u2500\u2500 templates\n \u00a0 \u00a0        \u2514\u2500\u2500 any nested amount of files...\n</code></pre> <p>The templates directory is usually a flat directory structure, but can be nested as well.</p>"},{"location":"scaffold-file/#file-reference","title":"File Reference","text":""},{"location":"scaffold-file/#questions-and-prompts","title":"Questions and Prompts","text":"<p>Questions are used to prompt the user for input when generating a scaffold. We support the following types of questions</p> <ul> <li>Text</li> <li>Confirm (Yes/No)</li> <li>Select One</li> <li>Multi Select</li> </ul> <p>They share a base type of question with the following fields</p> <code>name</code> <p>The name of the variable that will be used in the template. {{ .Scaffold. }} <code>required</code> <p>Whether or not the question is required.</p> <code>when</code> <p>A go template will will be evaluated with the previous context to conditionally render the questions. If the template evaluates to <code>false</code> the question will not be rendered, otherwise it will be. This is done by using the <code>strconv.ParseBool</code> function to parse the result of the template. Previous question variables are available at the root level {{ .previous_name }} instead of inside a .Scaffold container.</p> <code>prompt</code> <p>Prompt configured the type of questions to display to the user. See the examples below for more details.</p> <code>message</code> <p>The message field is the message that will be displayed to the user. If only this field is specified, the user will be prompted for a text input.</p> <code>description</code> <p>The description field is an optional field that will be displayed to the user as a description of the question.</p> <code>loop</code> <p>When the loop field is true, and the question is a text question, the user will be prompted to enter multipel values until they enter an empty string. The resulting type will be an array of string.</p> <code>confirm</code> <p>The confirm field is the message that will be displayed to the user. If only this field is specified, the user will be prompted for a yes/no input.</p> <code>options</code> <p>The options field is a list of options that will be displayed to the user. This requires the message field to be specified as well.</p> <code>multi</code> <p>The multi field is a boolean that will allow the user to select multiple options. This requires the message and options fields to be specified as well.</p> <code>default</code> <p>The default field is the default value(s) that will be used if the user does not provide an answer.</p>"},{"location":"scaffold-file/#question-examples","title":"Question Examples","text":"<pre><code>questions:\n  - name: \"description\"\n    prompt:\n      message: \"Description of the project\"\n    required: true\n  - name: \"CLI Commands\"\n    prompt:\n      message: \"CLI Commands\"\n      description: \"Enter a list of cli commands to stub out\"\n      loop: true\n  - name: \"license\"\n    prompt:\n      message: \"License of the project\"\n      default: \"MIT\"\n      options:\n        - \"MIT\"\n        - \"Apache-2.0\"\n        - \"GPL-3.0\"\n        - \"BSD-3-Clause\"\n        - \"Unlicense\"\n  - name: \"use_github_actions\"\n    prompt:\n      confirm: \"Use Github Actions for CI/CD?\"\n  - name: \"colors\"\n    when: \"{{ .use_github_actions }}\"\n    prompt:\n      multi: true\n      message: \"Colors of the project\"\n      default: [\"red\", \"green\"]\n      options:\n        - \"red\"\n        - \"green\"\n        - \"blue\"\n        - \"yellow\"\n</code></pre>"},{"location":"scaffold-file/#question-groups","title":"Question Groups","text":"<p>Questions also support grouping. Grouping questions will show them together in the rendered form so the user can toggle between them before submitting to the next question. Any questions that don't specify the <code>group</code> property will be grouped into their own group.</p> <pre><code>- name: \"grouped\"\n  group: \"Group 1\"\n  prompt:\n    message: \"Grouped Question 1\"\n- name: \"grouped2\"  \n  group: \"Group 1\"\n  prompt:\n    message: \"Grouped Question 2\"   \n</code></pre> <p>Warning</p> <p>When grouping questions the behavior of the <code>when</code> field changes. Only the first question in the group will be evaluated for the <code>when</code> field, and that results (true/false) applies to the entire group. You cannot apply the <code>when</code> condition to individual fields within a group. If you need to filter specific questions, you cannot use groups.</p>"},{"location":"scaffold-file/#computed-variables","title":"Computed Variables","text":"<p>Computed variables are variables that are computed from the answers to the questions. The following example will compute the <code>shuffled</code> variable from the <code>Project</code> variable.</p> <pre><code>computed:\n  shuffled: \"{{ shuffle .Project }}\"\n</code></pre> <p>You can reference computed variables like so</p> <pre><code>{{ .Computed.shuffled }}\n</code></pre> <p>Tip</p> <p>Computed variables are generally of type string however, there are special cases for boolean and integer types. Scaffold will attempt to parse the computed string value into an integer, and then a boolean. If any are successful, that value will be used in-place of the string.</p>"},{"location":"scaffold-file/#rewrites","title":"Rewrites","text":"<p>Rewrites working with the template scaffolds to perform a path rewrite to another directory. The following example defines a rewrite that will render the <code>templates/defaults.yaml</code> file to the <code>roles/{{ .ProjectKebab }}/defaults/main.yaml</code> path.</p> <pre><code>rewrites:\n  - from: templates/defaults.yaml\n    to: roles/{{ .ProjectKebab }}/defaults/main.yaml\n</code></pre> <ul> <li><code>from</code> - The path to the template file</li> <li><code>to</code> - a template path to the destination file</li> <li>These files are rendered with the template engine</li> </ul> <p>This feature is not available for project scaffolds.</p>"},{"location":"scaffold-file/#skips","title":"Skips","text":"<p>Skip is a list of glob patterns that will be used to skip the template rendering process. This is useful is your file is itself a go template, or contains similar syntax that will cause the template engine to fail. The following example will skip the <code>templates/defaults.yaml</code> file from being rendered.</p> <pre><code>skip:\n  - \"*.goreleaser.yaml\"\n  - \"**/*.gotmpl\"\n</code></pre>"},{"location":"scaffold-file/#inject","title":"Inject","text":"<p><code>inject</code> is a list of code/text injections to perform on a given file. This is to be used in conjunction with <code>scaffold templates</code> and is not supported within a <code>scaffold project</code>.</p> <p>The following example will inject a role into the <code>site.yaml</code> file at the output directory.</p> <code>name</code> <p>The name of the injection</p> <code>path</code> <p>The relative path to the file to inject into from the output directory</p> <code>at</code> <p>The location to inject the code/text. This is evaluated using the strings.Contains function. Note that ALL matches will be replaced.</p> <code>template</code> <p>The template to inject into the file. These work the same as scaffold templates.</p> <pre><code>inject:\n  - name: \"add role to site.yaml\"\n    path: site.yaml\n    at: \"# $Scaffold.role_name\"\n    template: |\n      - name: {{ .Scaffold.role_name }}\n        role: {{ .Computed.snaked }}\n</code></pre>"},{"location":"scaffold-file/#messages","title":"Messages","text":"<p>You can specify messages to show the user that are rendered using the glamour markdown renderer to show pre and post messages to the user.</p> <pre><code>messages:\n  pre: |\n    # Pre Message\n\n    This is a pre message that will be shown to the user before the scaffold is generated.\n\n    Template variables are _NOT_ available in this message.\n\n  post: |\n    # Post Message\n\n    This is a post message that will be shown to the user after the scaffold is generated.\n\n    You can use variables just as you would in your templates.\n\n    {{ .ProjectKebab }}\n</code></pre>"},{"location":"scaffold-file/#features","title":"Features","text":"<p>Scaffold support the concept of \"feature flags\" that can be used to conditionally render entire directories/glob matches of files. This is useful if you want to provide a scaffold that can have wide-reaching optional features, like a database, CI pipeline, etc.</p> <p>Features are lists of globs that will be evaluated against the <code>value</code> field. If the value is parsed to <code>true</code> the glob will be rendered, otherwise it will be skipped.</p> <pre><code>features:\n  - value: \"{{ .Scaffold.database }}\"\n    globs:\n      - \"**/core/database/**/*\"\n</code></pre>"},{"location":"scaffold-file/#presets","title":"Presets","text":"<p>Presets are a way to define a set of default values for a scaffold. These can be overridden by the user when running the scaffold.</p> <pre><code>presets:\n  default:\n    description: \"A description of the project\"\n    license: \"MIT\"\n    use_github_actions: true\n    colors: [\"red\", \"green\"]\n</code></pre> <p>Presets and Testing</p> <p>Presets can be used in conjunction with the <code>new</code> command for testing purposes. See Testing Scaffolds for more information.</p>"},{"location":"scaffold-rc/","title":"Scaffold RC","text":"<p>Scaffold RC is the runtime configuration file that can be used to define some default values and perform some basic enhancements to the scaffolding process. Your scaffoldrc path is defined by:</p> <ul> <li>The <code>--scaffoldrc</code> flag</li> <li>the <code>SCAFFOLDRC</code> environment variable</li> </ul> <p>Default: <code>~/.scaffold/scaffoldrc.yml</code></p>"},{"location":"scaffold-rc/#defaults","title":"Defaults","text":"<p>The <code>defaults</code> section allows you to set some default values for the scaffolding process. These can be any key/value string pairs</p> <pre><code>defaults:\n  name: Joe Bagadonuts\n  github_username: joebagadonuts\n  email: joebags@donus.gonuts\n</code></pre> <p>Tip</p> <p>Note that defaults are only used for text type questions at this time.</p>"},{"location":"scaffold-rc/#aliases","title":"Aliases","text":"<p>The <code>aliases</code> section allows you to define key/value pairs as shortcuts for a scaffold path. This is useful to shorten a reference for a specific scaffold.</p> <pre><code>aliases:\n  api: ~/local-scaffolds/api\n  component: ~/local-scaffolds/component\n</code></pre> <p>Then you can use the alias in the <code>scaffold</code> command</p> <pre><code>scaffold new api\n</code></pre>"},{"location":"scaffold-rc/#shorts","title":"Shorts","text":"<p>The <code>shorts</code> section allows you to define expandable text snippets. Commonly these would be used to prefix a URL or path.</p> <pre><code>shorts:\n  gh: https://github.com/\n  gl: https://gitlab.com/\n</code></pre> <p>Then you can use the alias in the <code>scaffold</code> command</p> <pre><code>scaffold new gh:joebagadonuts/my-project\n</code></pre> <p>Which will expand to</p> <pre><code>scaffold new https://github.com/joebagadonuts/my-project\n</code></pre>"},{"location":"scaffold-rc/#auth","title":"Auth","text":"<p>The <code>auth</code> sections lets you define authentication matchers for your scaffolds. This is useful for using scaffolds that are stored in a private repository.</p> <p>The configuration supports basic authentication and token authentication. Note that in most cases, you want basic authnetication, even us you're using a personal access token.</p> <pre><code>auth:\n  - match: github.com/private-repo/*\n    basic:\n      username: joebagadonuts\n      password: ${GITHUB_PASSWORD} # this will be replaced with the environment variable\n  - match: gitea.com/private-repo/*\n    token: ${GITEA_TOKEN} # this will be replaced with the environment variable\n</code></pre> <p>Tip</p> <p>the <code>match</code> key supports regular expressions giving you a lot of flexibility in defining your matchers.</p>"},{"location":"scaffold-resolution/","title":"Scaffold Resolution","text":"<p>Scaffold uses a resolution system to find the correct scaffold to use when generating a project. This system may seem complicated at first, however I reason that it is flexible enough to handle most use cases without being overly un-intuitive.</p> <pre><code>graph TD;\n  A(Invoke Command) --&gt; B(Expand Aliases);\n  B --&gt; C{Is Remote URL?}\n  C --&gt; |Yes| D{Already Cloned?};\n  D --&gt; |Yes| Z;\n  D --&gt; |No| E(Clone Repository);\n  E --&gt; Z;\n\n  C --&gt; |No| F{Is Absolute Path};\n  F --&gt; |Yes| Z;\n\n  F --&gt; |No| G{Contains '/'};\n  G --&gt; |Yes| H(Assume Relative Path);\n  H --&gt; Z;\n\n  G --&gt; |No| I(Search Scaffold Dirs for Match);\n  I --&gt; |Found| Z;\n  I --&gt; |Not Found| J(Error);\n\n  Z[Run Scaffold];</code></pre>"},{"location":"template-engine/","title":"Template Engine","text":""},{"location":"template-engine/#overview","title":"Overview","text":"<p>Scaffold uses the Go template engine to generate files. The following variables are available to use in your templates at a top level:</p> <ul> <li><code>Project</code> - The name of the project</li> <li><code>ProjectKebab</code> - The kebab case version of the project name</li> <li><code>ProjectSnake</code> - The snake case version of the project name</li> <li><code>ProjectCamel</code> - The camel case version of the project name</li> <li><code>Scaffold</code> - a map of the scaffold questions and answers</li> </ul> <p>The templates also make available the <code>sprout</code> library of functions. See the sprout documentation for more information.</p> <p>We also provide the following functions that help with rendering templates:</p> <code>wraptmpl</code> <p>Wraps a string in <code>{{</code> and <code>}}</code> so it can be used as a template. This can also be accomplished by escaping the template syntax. For example, <code>{{ \"{{ .Project }}\" }}</code> will render as <code>{{ .Project }}</code>.</p> <p><code>{{ wraptmpl \"docker_dir\" }}</code> -&gt; <code>{{ \"docker_dir\" }}</code></p> <p>vs</p> <p><code>{{ \"{{ docker_dir }}\" }}</code> -&gt; <code>{{ docker_dir }}</code></p>"},{"location":"template-engine/#engine-rules","title":"Engine Rules","text":"<p>The template process also uses the following rules for rendering:</p> <ol> <li>Empty files are skipped.</li> <li>Template files that are empty after rendering are not included in the generated project.</li> <li>Empty directories not included in the generated project</li> </ol>"},{"location":"testing-scaffolds/","title":"Testing Scaffolds","text":"<p>Scaffold does not have a test command or framework, however it does provide some tools that can be utilized to implement tests for your scaffolds.</p>"},{"location":"testing-scaffolds/#testing-with-asts","title":"Testing with ASTs","text":"<p>Scaffold provides a way to output an AST of the scaffolded files. This can be used with a diffing tool to compare the ASTs of the scaffolded files with the expected ASTs to ensure that the scaffolded files are correct.</p> <pre><code># Command\nscaffold \\\n    --log-level=\"error\" \\     # set log level to error to avoid noise\n    --output-dir=\":memory:\" \\ # render scaffold in memory\n    new \\\n    --preset=\"default\" \\      # use scaffold preset\n    --no-prompt \\             # disable interactive prompts\n    --snapshot=\"stdout\" \\     # write snapshot to stdout\n    &lt;scaffold&gt;\n\n# Output\nscaffold-test-5781:  (type=dir)\n        main.go:  (type=file)\n                package main\n\n                import (\n                        \"fmt\"\n                )\n\n                func main() {\n                        fmt.Println(\"colors=red, green description=This is a test description\")\n                }\n</code></pre>"},{"location":"testing-scaffolds/#testing-with-outputs","title":"Testing with Outputs","text":"<p>An alternative approach is to test out output scaffolds by running whatever output is generated by the scaffold. For example, we use this approach to test our scaffolds by generating a Go program and running it to ensure that it compiles and runs as expected.</p> <p>See cli.test.sh for an example of how to test scaffolds using this approach.</p>"}]}